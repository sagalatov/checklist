
## Web
* сессии
* JWT (JSON Web Token) token
* cors
* csrf
* headers (cache, useragent, location)
* cookie
* get, post, option; body, query; http status
* REST - принципы наименование методов, принцип stateless
* Используемые коды ошибок
* CSP (Content Security Policy)
* TSP/IP
* HTTP2
* WebSocket
* OAuth
* Service Worker
* Web Worker 

### Сессии
Это некоторый отрезок во времени, в пределах которого веб-приложение может определять все запросы от одного клиента. 
(Когда клиент в первые передает свои данные в запросе, на сервере создается новая сессия для этого клиента и в пределах 
и в период времени жизни сессии  все запросы от этого клиента будут однозначно идентифицированы только с ним, по истечению времени запрос связь будет потеряна и новый запрос будет обрабатываться как совершенно новый и не связанный с клиентом)
Данные сессии хранятся на бэкенде в базе данных.

### JWT token
**JWT (JSON Web Token)** — это открытый стандарт для создания токенов доступа, основанный на формате JSON. Обычно он используется для передачи данных для аутентификации пользователей в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются юзеру, который в дальнейшем использует их для подтверждения своей личности.  
Простейший сценарий использования JWT-токенов следующий:

• пользователь регистрируется/логинится в системе, ему выписывается токен;

• этот токен сохраняется на стороне клиента;

• каждый следующий свой запрос клиент делает с заголовком:
Authorization: Bearer <token>

• сервер, получая запрос с таким заголовком, проверяет его валидность. И в случае успеха отправляет запрашиваемый контент.

### Сравнение авторизации по сессии и JWT.
JWT подходит для распределенных и систем (микросервисы), поддерживает масштабируемость и не требует сохранения данных на сервере. Сессии более безопасны для хранения критичных данных, так как они не содержат самих данных сессии на клиенте, но требуют управления хранилищем на сервере и менее удобны для распределенных архитектур.

### Сors
CORS — это механизм безопасности, который позволяет веб-странице из одного домена обращаться к ресурсу с другим доменом (кросс-доменным запросом). Без таких функций, как CORS, веб-сайты ограничиваются доступом к ресурсам одного 
и того же происхождения через так называемую политику единого происхождения.
Спецификация CORS определяет набор заголовков, которые позволяют серверу и браузеру определять, какие запросы для междоменных ресурсов (изображения, таблицы стилей, сценарии, данные и т. д.) разрешены, а какие нет. CORS является техникой для ослабления правила одного источника, позволяя JavaScript на web странице обрабатывать REST API запросы от другого источника.   
Для простых запросов браузер не отправляет предзапросы **preflight**, к ним относятся:
1. Простой метод: GET, POST или HEAD
2. Простой заголовок:
    Accept,
    Accept-Language,
    Content-Language,
    Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или text/plain.

Не простой запрос выглядит следующим образом:  
![Big_O](/img/preflight_request.png)  

### Сsrf    
CSRF-атака – это когда «злая страница» отправляет форму или запрос на сайт, где посетитель, предположительно, залогинен.
Если сайт проверяет только куки, то он такую форму принимает. А делать это не следует, так как её сгенерировал злой хакер.
Для защиты от атаки формы, которые генерирует mail.com, подписываются специальным токеном. Можно не все формы, 
а только те, которые осуществляют действия от имени посетителя, то есть могут служить объектом атаки.

### headers (cache, useragent, location )
    
* headers : HTTP заголовки сопровождают обмен данными по протоколу HTTP. Они могут содержать описание данных и информацию необходимую для взаимодействия между клиентом и сервером. Заголовки и их статусы перечислены в реестре IANA, который постоянно обновляется.

* cashe:  Кеширование - этот метод, заключающийся в сохранении копии полученного ресурса, чтобы вернуть ее по запросу. Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения к исходному серверу выполняется загрузка копии 
из кеша. Таким образом снижается нагрузка на сервер, которому не приходится самому обслуживать всех клиентов, и повышается производительность - кеш ближе к клиенту, и ресурс передается быстрее. Кеширование является  основным источником повышения производительности веб-сайтов. Однако, кеш надо правильно сконфигурировать: ресурсы редко остаются неизменными, так что копию требуется хранить только до того момента, как ресурс изменился, но не дольше.
Существует несколько видов кешей, которые можно разделить на две основные категории: приватные кеши и кеши совместного использования. В кешах совместного использования (shared cache) хранятся копии, которые могут направляться разным пользователями. Приватный кеш (private cache) предназначен для отдельного пользователя
useragent: User-Agent — это текстовая часть запроса, которую веб-приложения используют для сообщения сайту информации о себе. User-Agent браузера содержит название и версию приложения, а также данные об операционной системе компьютера: версия, разрядность, язык по умолчанию и другие параметры. 

* locationc: HTTP-заголовок Location возвращается в ответах HTTP-сервера в двух случаях:
Чтобы попросить браузер загрузить другую web-страницу (Перенаправление URL). В этом случае заголовок Location должен быть отправлен вместе с кодом состояния 3xx
Для предоставления информации о новом местоположении ресурса. Код состояния должен быть 201 или 202

### Cookie
HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это, в частности, позволяет узнать, 
с одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Они запоминают информацию о состоянии 
для протокола HTTP, который сам по себе этого делать не умеет.

Cookie используются, главным образом, для:
* Управления сеансом (логины, корзины для виртуальных покупок)  
* Персонализации (пользовательские предпочтения)   
* Мониторинга (отслеживания поведения пользователя)  

До недавнего времени cookie принято было использовать в качестве хранилища информации на стороне пользователя. Это могло 
иметь смысл в отсутствии вариантов, но теперь, когда в распоряжении браузеров появились различные API (программные интерфейсы приложения) для хранения данных, это уже не так. Из-за того, что cookie пересылаются с каждым запросом, они могут слишком сильно снижать производительность (особенно в мобильных устройствах). В качестве хранилищ данных на стороне пользователя вместо них можно использовать Web storage API (localStorage and sessionStorage) и IndexedDB.
#### Свойства cookies
* **path** - url префикс пути, куки будут доступны только по этому пути. Если куки установлено с path=/user, то оно будет доступно на страницах /user и /user/any, но не на страницах /home или /about.
* **domain** - домен на котором доступны куки, но нельзя дать доступ на другой домен, однако возможно отрыть доступ на поддомены. Установив `domain=site.com` кука доступна и скажем с поддомена `forum.site.com`.
* **expires, max-age** - позволяют установить время когда истечет кука или время в секундах до истечения.
* **secure** - с этим параметром кука не будет передаваться по http протоколу.
* **samesite** - параметр для защиты от csrf атак.
* **http only** - кука не доступна из js

### Get, post, option; body, query; http status
        
* get: метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.

* post: в программировании POST — один из многих методов запроса, поддерживаемых HTTP протоколом, используемым во Всемирной паутине. Метод запроса POST предназначен для запроса, при котором веб-сервер принимает данные, заключённые в тело сообщения, 
для хранения. Он часто используется для загрузки файла или представления заполненной веб-формы.

* option: HTTP-метод OPTIONS используется для описания параметров соединения с целевым ресурсом. Клиент может указать особый URL для обработки метода OPTIONS, или * (зведочку) чтобы указать весь сервер целиком.

* body

    Тело запроса. Оно бывает не у всех запросов: запросы, собирающие (fetching) ресурсы, такие как GET, HEAD, DELETE, 
    или OPTIONS, в нем обычно не нуждаются. Но некоторые запросы отправляют на сервер данные для обновления, как это часто         бывает с запросами POST (содержащими данные HTML-форм)
    Тела можно грубо разделить на две категории: 
    Одноресурсные тела (Single-resource bodies), состоящие из одного отдельного файла, определяемого двумя заголовками:           Content-Type и Content-Length.
    Многоресурсные тела (Multiple-resource bodies), состоящие из множества частей, каждая из которых содержит свой бит             информации. Они обычно связаны с HTML-формами.

    Тело ответа. Оно есть не у всех ответов: у ответов с кодом состояния, например, 201 или 204, оно обычно отсутствует.
    Тела можно разделить на три категории:
    Одноресурсные тела (Single-resource bodies), состоящие из отдельного файла известной длины, определяемые двумя                 заголовками: Content-Type и Content-Length.
    Одноресурсные тела (Single-resource bodies), состоящие из отдельного файла неизвестной длины, разбитого на небольшие части     (chunks) с заголовком Transfer-Encoding, значением которого  является chunked.
    Многоресурсные тела (Multiple-resource bodies), состоящие из многокомпонентного тела, каждая часть которого содержит свой     сегмент информации. Они относительно редки.

* query: cтрока запроса - часть унифицированного указателя ресурса  
Пример: <http://example.com/over/there?name=ferret&сOlof=purpule>  
? - разделитель  
& - разделитель множественных запросов  

    Ссылка по теме: ru.qwe.wiki/wiki/query_string

* http: HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных изначально — в виде гипертекстовых документов в формате «HTML», в настоящий момент используется для передачи произвольных данных. Основой HTTP является технология «клиент-сервер», то есть предполагается существование:
Потребителей (клиентов), которые инициируют соединение и посылают запрос;
Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.

* status: Код состояния HTTP (англ. HTTP status code) — часть первой строки ответа сервера при запросах по протоколу HTTP. 
Он представляет собой целое число из трёх десятичных цифр. Первая цифра указывает на класс состояния. За кодом ответаобычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа
<https://yandex.ru/support/webmaster/error-dictionary/http-codes.html>

### REST - принципы наименование методов, принцип stateless
REST (Representational state transfer) – это стиль архитектуры программного обеспечения для распределенных систем, таких 
как World Wide Web, который, как правило, используется для построения веб-служб. Термин REST был введен в 2000 году 
Роем Филдингом, одним из авторов HTTP-протокола. Системы, поддерживающие REST, называются RESTful-системами.  
Каждая единица информации однозначно определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет строго заданный формат.

* Принципы наименования: www.restapitutorial.ru/lessons/restfulresourcenaming.html  

* Принцип stateless  
Состояние хранится на клиенте 

Ссылка: <TODO>  

### Используемые коды ошибок

TODO

### CSP - Content security policy
Технология позволяющая распознать и устранить атаки внедрения данных такие как XSS. Может быть настроен с помощью тэга meta.
Позволяет указать какие данные и с каких доменов можно подгружать.  
`Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com`  
При такой настройке, весь контент доступен для получения только с исходного домена, со следующими исключениями:  
Изображения могут быть получены из любого источника (источник - "*").
Другие медиа-файлы доступны только с media1.com и media2.com (но не с их поддоменов).
Исполняемый код доступен только с userscripts.example.com.

***
### TCP/IP
TCP/IP - сетевая модель передачи данных, представленных в цифровом виде. Модель описывает способ передачи данных от источника информации к получателю. В модели предполагается прохождение информации через четыре уровня, каждый из которых описывается правилом (протоколом передачи).  
* Прикладной уровень (Application Layer) напр., HTTP, RTSP, FTP, DNS
* Транспортный уровень (Transport Layer) напр., TCP, UDP, SCTP, DCCP
* Межсетевой уровень (Internet Layer) Для TCP/IP это IP
* Канальный уровень (Network Access Layer) Ethernet, IEEE 802.11, WLAN. Физическая среда.  

Физический интерфейс передаёт данные фреймами. Фрейм имеет заголовок и полезные данные (payload). В заголовке фрейма указывается MAC-адрес получателя, MAC-адрес отправителя и какому протоколу принадлежат данные в payload (Ethertype). Где MAC адрес - адрес физического устойства, а IP логический адрес.

#### SSL 
SSL или его наследник TLS прикладной протокол, более высокого уровня чем TCP/IP. Позволяет осуществлять безопасное HTTP соединение (HTTPS)
TLS – гибридная криптографическая система. Это означает, что она использует несколько криптографических подходов, которые мы и рассмотрим далее:

* Асиметричное шифрование (криптосистема с открытым ключом) для генерации общего секретного ключа и аутентификации (то есть удостоверения в том, что вы – тот за кого себя выдаете).
* Симметричное шифрование, использующее секретный ключ для дальнейшего шифрования запросов и ответов.

#### Криптосистема с открытым ключом
Криптографическая система в которой у каждоый стороны есть открытый и закрытый ключ математически связанные между собой. Открытый ключ используется для шифромания сообщения, а закрытый для дешифровки и получения исходного текста.

#### Сертификаты CA
Для аутентификации пользователей в сети https используются цифровые сертификаты. По сути, сертификаты связывают доменные имена с определенным публичным ключом.
##### Как работает сертификат
1. Пользователь отправляет запрос на подключение к сайту, защищённому протоколом. Например, переходит по ссылке или вводит адрес в адресной строке браузера.
2. Браузер пользователя по протоколу HTTPS спрашивает у сервера сайта, подлинный ли он.
3. Сервер в ответ пересылает копию своего сертификата SSL и публичный ключ.
4. Браузер пользователя сверяет полученный сертификат с пунктами выдачи сертификатов, удостоверяется в его подлинности и отправляет серверу подтверждение, которое зашифровывает публичным ключом.
5. Сервер создаёт защищённый сеанс: отправляет браузеру подтверждение с уникальной цифровой подписью, которая зашифрована протоколом SSL.
6. Защищённое соединение установлено: данные передаются по браузер-серверному соединению.
Совместно все выше указанные технологии позволяют установить https соединение.

#### HTTP2
Приемущества использования HTTP2:  
* Мультиплексированная асинхронная передача данных: на одном соединении запросы разделяются на чередующиеся пакеты, сгруппированные в отдельные потоки.
* Запросы приоритизируются, благодаря чему снимается проблема с одновременной отправкой всех запросов.
* В отличие от текстового протокола HTTP, HTTP/2 - бинарный. Благодаря этому можно обрабатывать небольшие сообщения, из которых формируются более крупные.
* Server Push. Если в версии HTTP/1 браузер должен был сначала получить домашнюю страницу, и лишь из неё понять, какие ресурсы ему необходимы для рендеринга, то HTTP/2 позволяет отправить все необходимые ресурсы сразу, при первичном обращении к серверу.

### WebSocket
Протокол для общения между клиентом и сервером, предоставляющий двухсторонне общение сверх протокола TCP.  
Первое что мы делаем — отправляем обычный TCP-запрос на сервер, мы говорим, что хотим подключиться к серверу и ждём от него ответа. Такой процесс называется “рукопожатие” (Handshake).  
```
// Отправляем запрос серверу по ссылке example.com/connect-to-ws
// Вот что примерно мы пришлём:
GET /connect-to-ws HTTP/1.1
Host: example.com:8000
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13

// А вот что нам на такой запрос ответит сервер при успешном рукопожатии:
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

Как мы видим сервер ответил не кодом 200 (успешное завершение запроса), а 101 — переключение протоколов. Это происходит потому, что мы отправили HTTP запрос, а хотим получить не только HTTP-ответ, а ещё и другие ответы по WS.  
Сервер периодически присылает ответ по WS с просьбой о действии - послать запрос на сервер. Если клиент отвечает до истечения тайм-аута — он подключен, если нет, то происходит разрыв соединения до следующего рукопожатия.

### OAuth (Open Authorization) 
Это широко используемый протокол, который позволяет сторонним приложениям получать ограниченный доступ к ресурсам пользователя на других сервисах (например, Google, Facebook, Twitter) без необходимости передавать логин и пароль.  
#### Основные термины
**Access Token** (Токен доступа): Токен, предоставляющий клиенту доступ к ресурсам пользователя на ограниченный период и с определенными правами.  
**Refresh Token** (Обновляющий токен): Используется для получения нового токена доступа, когда старый истекает.  
**Authorization Code** (Код авторизации): Временный код, который клиент получает после того, как пользователь разрешает доступ к своим данным. Этот код затем обменивается на токен доступа.  
#### Типовой сценарий
1. Приложение перенаправляет пользователя на страницу авторизации Google.
2. Пользователь входит в свой аккаунт Google и соглашается предоставить доступ к контактам.
3. Приложение получает Authorization Code (OAuth-сервер перенаправляет пользователя обратно на redirect_uri с временным Authorization Code).
4. Приложение отправляет Authorization Code на сервер Google для получения Access Token (на бэкенде приложения).
5. Используя Access Token, приложение получает доступ к контактам пользователя через Google API (на бэкенде прилодения). Далее данные могут быть направлены в интефейс.

### Service Worker
Service Worker — это скрипт, работающий в фоновом режиме, отдельно от основного потока вашего веб-приложения, который позволяет управлять сетевыми запросами, кэшировать ресурсы и предоставлять оффлайн-функциональность. Это ключевой элемент в реализации прогрессивных веб-приложений (PWA), который помогает улучшить производительность и надежность веб-приложений.  
[Что такое Service Worker](https://habr.com/ru/companies/2gis/articles/345552/)

### Web Worker 
Web Worker — это технология в JavaScript, которая позволяет выполнять код в отдельном потоке, параллельно с основным потоком веб-страницы. Это полезно для выполнения длительных операций, таких как вычисления, загрузка данных или работа с файлами, без блокировки пользовательского интерфейса (UI).
